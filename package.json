{
  "name": "puzzle",
  "version": "1.0.0",
  "description": "Vue Puzzle\r ===\r 資料定義\r ---\r 拼圖資料；\r ```JS\r puzzleData: {\r   'name': '作品標題',\r   'xNum': 拼圖x軸個數,\r   'yNum': 拼圖y軸個數,\r   'bgImgUrl': '背景圖片路徑',\r   'puzzleUrl': '拼圖路徑前綴',\r   'puzzlePos': [拼圖的絕對定位],\r   'fullName': '作品全名',\r   'author': '作者',\r   'age': '作品年代',\r   'inform': '作品資料',\r }\r ```\r 結合的拼圖紀錄：\r ```JS\r data-combine\r ```\r 相鄰的拼圖索引紀錄：\r ```JS\r siblsIdxArr: []\r ```\r directives\r ---\r 定義拼圖拖動：\r ```JS\r drag(el,binding) {\r     el.onmousedown=function(e){\r         e.stopPropagation();\r         let puzzles = document.querySelectorAll('.puzzle');\r         let combinePuzzles = [];\r         combinePuzzles = JSON.parse(`[${el.getAttribute('data-combine')}]`);        //獲取已拼接的拼圖索引\r         let combineLen = combinePuzzles.length;\r         let filtedArr = [];\r         for(i=0; i<combineLen; i++){        //刪除combinePuzzles內重複的項目\r             for(j=i+1; j<combineLen; j++){\r                 if(combinePuzzles[i] == combinePuzzles[j]){\r                     j = ++i\r                 };\r             };\r             filtedArr.push(combinePuzzles[i]);\r         };\r         let dist = [];\r         let windowW = document.body.clientWidth;\r         let windowH = document.body.clientHeight;\r         let puzzleH = el.offsetHeight;\r         let puzzleW = el.offsetWidth;\r         let filtedLeng = filtedArr.length;\r         for(i=0; i<filtedLeng; i++){\r             let index = filtedArr[i];\r             dist.push({\r                 x: e.clientX - puzzles[index].offsetLeft,\r                 y: e.clientY - puzzles[index].offsetTop\r             })\r         };\r         document.onmousemove = function (e){\r             e.preventDefault();\r             let inRange = true;\r             for(i=0; i<filtedLeng; i++){\r                 if(e.clientX - dist[i].x<0 || windowW - e.clientX + dist[i].x - puzzleW<0 || \r                 e.clientY - dist[i].y<0 || windowH - e.clientY + dist[i].y - puzzleH<0){\r                     inRange = false;\r                     break\r                 }\r             };\r             if(inRange){        //確認不會超出視窗後讓所有已拼接的拼圖隨著滑鼠移動\r                 for(i=0; i<filtedLeng; i++){\r                     let index = filtedArr[i];\r                     puzzles[index].style.left = e.clientX - dist[i].x + 'px';\r                     puzzles[index].style.top = e.clientY - dist[i].y + 'px';\r                 }\r             };\r         }\r         document.onmouseup = function(){\r             document.onmousemove = null;\r         }\r     }\r }\r ```\r 確認拼圖位置\r ---\r ```JS\r getSiblsPos(e){\r     let puzzles = document.querySelectorAll('.puzzle');\r     let combinePuzzles = JSON.parse(`[${e.currentTarget.getAttribute('data-combine')}]`);\r     let xNum = this.puzzleData.xNum;\r     let yNum = this.puzzleData.yNum;\r     combinePuzzles.forEach( el => {       //需確認每個已拼接的拼圖位置\r         let top = puzzles[el].offsetTop;\r         let left = puzzles[el].offsetLeft;\r         this.siblsIdxArr[el].forEach( element => {\r             switch(element - el){       //確認使否與新的拼圖拼接\r                 case xNum:\r                     if(Math.abs(puzzles[element].offsetTop - top - 144) < 8 && \r                     Math.abs(puzzles[element].offsetLeft - left) <8){\r                         this.combine(element, el, puzzles, -144, 0);\r                     }\r                 case 1:\r                     if(Math.abs(puzzles[element].offsetTop - top) < 8 && \r                     Math.abs(puzzles[element].offsetLeft - left - 144) <8){\r                         this.combine(element, el, puzzles, 0, -144);\r                     }\r                     break\r                 case -1:\r                     if(Math.abs(puzzles[element].offsetTop - top) < 8 && \r                     Math.abs(puzzles[element].offsetLeft - left + 144) <8){\r                         this.combine(element, el, puzzles, -0, 144);\r                     }\r                     break\r                 case -xNum:\r                     if(Math.abs(puzzles[element].offsetTop - top + 144) < 8 && \r                     Math.abs(puzzles[element].offsetLeft - left) <8){\r                         this.combine(element, el, puzzles, 144, 0);\r                     }\r                     break\r             }\r         })\r     });\r     let combinePuzzlesUpdate = JSON.parse(`[${e.currentTarget.getAttribute('data-combine')}]`);       //確認是否全數拼圖已拼接\r     if(combinePuzzlesUpdate.length == 9){\r         this.complete();\r     };\r }\r ```\r 拼圖結合\r ---\r 拼接：\r ```JS\r combinePuzzle(el1, el2, els, topIncr, leftIncr, idxArr1, idxArr2) {\r     let top1 = parseInt(el1.style.top);\r     let left1 = parseInt(el1.style.left);\r     let top2 = parseInt(el2.style.top);\r     let left2 = parseInt(el2.style.left);\r     let posDiff = [];\r     let length = idxArr2.length;\r     idxArr2.forEach(el => {\r         posDiff.push({\r             top: parseInt(els[el].style.top) - top2,\r             left: parseInt(els[el].style.left) - left2\r         })\r     });\r     for(i=0; i<length; i++){        //將全數已拼接拼圖移動，拚上新的拼圖\r         let index = idxArr2[i];\r         els[index].style.top = top1 + topIncr + posDiff[i].top + 'px';\r         els[index].style.left = left1 + leftIncr + posDiff[i].left + 'px';\r     };\r     idxArr1.forEach(el => {       //將拼接上的拼圖索引從相鄰索引上去除，避免重複觸發拼接發光動畫\r         els[el].classList.add('box-shadow');\r         setTimeout(() => {\r             els[el].classList.remove('box-shadow')\r         }, 500);\r     });\r     idxArr2.forEach(el => {\r         els[el].classList.add('box-shadow');\r         setTimeout(() => {\r             els[el].classList.remove('box-shadow')\r         }, 500);\r     });\r }\r ```\r data合併：\r ```JS\r combineData(el1, el2, els){\r     let str = `${el1.getAttribute('data-combine')}, ${el2.getAttribute('data-combine')}`;       //合併拼接雙方的已拼接索引\r     let idxArr1 = JSON.parse(`[${el1.getAttribute('data-combine')}]`);\r     let idxArr2 = JSON.parse(`[${el2.getAttribute('data-combine')}]`);\r     let length1 = idxArr1.length;\r     let length2 = idxArr2.length;\r     for(i=0; i<length1; i++){       //將合併後的索引寫入\r         let index = idxArr1[i];\r         els[index].setAttribute('data-combine', str);\r     };\r     for(i=0; i<length2; i++){\r         let index = idxArr2[i];\r         els[index].setAttribute('data-combine', str);\r     };\r }\r ```\r 拼圖z-index\r ---\r ```JS\r changeZIdx(e) {\r     let puzzles = document.querySelectorAll('.puzzle');\r     let combinePuzzles = JSON.parse(`[${puzzles[[...puzzles].indexOf(e.currentTarget)].getAttribute('data-combine')}]`);\r     combinePuzzles.forEach(el => {        \\\\讓所有拼接拼圖的z-index改變，至於最上層\r         puzzles[el].style.zIndex = this.zIndex;\r     });\r     this.zIndex++;\r }\r ```",
  "main": "index.js",
  "devDependencies": {
    "babel-eslint": "^10.0.2",
    "node-sass": "^4.12.0",
    "sass-loader": "^7.1.0",
    "gulp-gh-pages": "^0.5.4",
    "gulp": "^4.0.2"
  },
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "repository": {
    "type": "git",
    "url": "git+https://github.com/ChenDarYen/puzzle1.git"
  },
  "author": "",
  "license": "ISC",
  "bugs": {
    "url": "https://github.com/ChenDarYen/puzzle1/issues"
  },
  "homepage": "https://github.com/ChenDarYen/puzzle1#readme"
}
