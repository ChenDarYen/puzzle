<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Puzzle</title>
    <link rel="stylesheet" href="css/main.css">
</head>
<body>
<div id="app">
    <div class="bg-blur"
    :style="{backgroundImage: `url(${puzzleData.bgImgUrl})`}"></div>
    <template v-if="!isClear">
        <div id="title" 
        :style="{'z-index': zIndex+1}" key="0">
            <h1 >請完成這幅《{{ puzzleData.name }}》</h1>
        </div>
        <button id="reset"  
        @click="reset" :style="{'z-index': zIndex+1}" key="1">重新排列</button>
    </template>
    <div id="puzzle-content" v-if="!isComplete" key="2">
        <div class="puzzle" data-combine=""
        v-for="(pos, idx) in puzzleData.puzzlePos" :key="idx + 10" v-drag
        @mousedown="changeZIdx" @mouseup="getSiblsPos">
            <img :src="puzzleData.puzzleUrl + (idx+1) + '.png'"
            :style="{position:'absolute',
            top: `${pos.y}px`,
            left: `${pos.x}px`}">
        </div>
    </div>
    <div id="complete-puzzle" key="3">
        <img src="image/img-Qingming.png" alt="清本院清明上河圖" class="picture" v-if="isComplete">
    </div>
    <div id="intro" v-if="isClear" key="4">
        <h1>{{ puzzleData.fullName }}</h1>
        <h2>{{ puzzleData.author }}</h2>
        <h2>{{ puzzleData.age }}</h2>
        <div class="inform">
            <p v-for='artical in puzzleData.inform'>{{ artical }}</p>
        </div>
        <button class="again" 
        @click="playAgain">在玩一次</button>
    </div>
</div>
<script src="js/all.js"></script>
<script src="https://cdn.jsdelivr.net/npm/vue@2.6.10/dist/vue.js"></script>
<script src="js/jquery1.12.4.js"></script>
<script>

let app = new Vue({
    el: '#app',
    data: {
        zIndex: 10,
        isClear: false,
        isComplete: false,
        siblsIdxArr: [],
        puzzleData: {
            'name': '清明上河圖',
            'xNum': 3,
            'yNum': 3,
            'bgImgUrl': 'image/img-bg-Qingming.png',
            'puzzleUrl': 'image/Puzzle-',
            'puzzlePos': [
                {
                    y: 0,
                    x: 0 
                },
                {
                    y: 0,
                    x: -27 
                },
                {
                    y: 0,
                    x: 0
                },
                {
                    y: 0,
                    x: 0 
                },
                {
                    y: -27,
                    x: 0 
                },
                {
                    y: 0,
                    x: -27 
                },
                {
                    y: -27,
                    x: 0 
                },
                {
                    y: 0,
                    x: -27 
                },
                {
                    y: -27,
                    x: 0 
                },
            ],
            'fullName': '清本院清明上河圖',
            'author': '陳枚、孫祜、金昆、戴洪、程志道',
            'age': '清高宗乾隆元年（1736）',
            'inform': ['宋張澤端（活動於西元十二世紀前期）「清明上河圖」是畫史中寫實風俗畫的一件傑作，歷代臨仿者甚多，在故宮即藏有七種不同的本子，其中就屬清院本「清明上河圖」最為有名。', '此卷為乾隆元年（一七三六）由宮廷畫院畫師陳枚、孫祜、金昆、戴洪、程志道等五人合繪。 此卷設色鮮麗，用筆圓熟，界畫橋樑、屋宇及人物皆十分細膩嚴謹，是院畫中之極精者。所畫事物甚多，雖失去了宋代古制，但也足以代表明清之際北京風物。'],
        }
    },
    methods: {
        getSiblsIdxArr() {
            console.log(1);
            let puzzles = document.querySelectorAll('.puzzle');
            let siblsIdx = [];
            let xNum = this.puzzleData.xNum;
            let num = this.puzzleData.xNum * this.puzzleData.yNum;
            for(i=0; i<num; i++){
                switch(i % xNum){
                    case 0:
                        siblsIdx = [i-xNum, i+1, i+xNum]
                        break
                    case xNum-1:
                        siblsIdx = [i-xNum, i-1, i+xNum]
                        break
                    default:
                        siblsIdx = [i-xNum, i-1, i+1, i+xNum]
                };
                siblsIdx = siblsIdx.filter(el => {
                    return el>=0 && el<num
                });
                this.siblsIdxArr.push(siblsIdx);
            };
        },
        setData() {
            document.querySelectorAll('.puzzle').forEach((el, index) => {
                el.setAttribute('data-combine', index);
            })
        },
        changeZIdx(e) {
            let puzzles = document.querySelectorAll('.puzzle');
            let combinePuzzles = JSON.parse(`[${puzzles[[...puzzles].indexOf(e.currentTarget)].getAttribute('data-combine')}]`);
            combinePuzzles.forEach(el => {
                puzzles[el].style.zIndex = this.zIndex;
            });
            this.zIndex++;
        },
        combine(idx1, idx2, els, topIncr, leftIncr) {
            let el1 = els[idx1];
            let el2 = els[idx2];
            let siblsIdxArr = this.siblsIdxArr;
            let combineArr1 = JSON.parse(`[${el1.getAttribute('data-combine')}]`);
            let combineArr2 = JSON.parse(`[${el2.getAttribute('data-combine')}]`);
            combineArr1.forEach(el1 => {
                combineArr2.forEach(el2 => {
                    if(siblsIdxArr[el1].indexOf(el2) >= 0){
                        siblsIdxArr[el1].splice(siblsIdxArr[el1].indexOf(el2), 1);
                    };
                    if(siblsIdxArr[el2].indexOf(el1) >= 0){
                        siblsIdxArr[el2].splice(siblsIdxArr[el2].indexOf(el1), 1);
                    };
                })
            });
            this.combinePuzzle(el1, el2, els, topIncr, leftIncr, combineArr1, combineArr2);
            this.combineData(el1, el2, els)
        },
        combinePuzzle(el1, el2, els, topIncr, leftIncr, idxArr1, idxArr2) {
            let top1 = parseInt(el1.style.top);
            let left1 = parseInt(el1.style.left);
            let top2 = parseInt(el2.style.top);
            let left2 = parseInt(el2.style.left);
            let posDiff = [];
            let length = idxArr2.length;
            idxArr2.forEach(el => {
                posDiff.push({
                    top: parseInt(els[el].style.top) - top2,
                    left: parseInt(els[el].style.left) - left2
                })
            });
            for(i=0; i<length; i++){
                let index = idxArr2[i];
                els[index].style.top = top1 + topIncr + posDiff[i].top + 'px';
                els[index].style.left = left1 + leftIncr + posDiff[i].left + 'px';
            };
            idxArr1.forEach(el => {
                els[el].classList.add('box-shadow');
                setTimeout(() => {
                    els[el].classList.remove('box-shadow')
                }, 500);
            });
            idxArr2.forEach(el => {
                els[el].classList.add('box-shadow');
                setTimeout(() => {
                    els[el].classList.remove('box-shadow')
                }, 500);
            });
        },
        combineData(el1, el2, els){
            let str = `${el1.getAttribute('data-combine')}, ${el2.getAttribute('data-combine')}`;
            let idxArr1 = JSON.parse(`[${el1.getAttribute('data-combine')}]`);
            let idxArr2 = JSON.parse(`[${el2.getAttribute('data-combine')}]`);
            let length1 = idxArr1.length;
            let length2 = idxArr2.length;
            for(i=0; i<length1; i++){
                let index = idxArr1[i];
                els[index].setAttribute('data-combine', str);
            };
            for(i=0; i<length2; i++){
                let index = idxArr2[i];
                els[index].setAttribute('data-combine', str);
            };
        },
        complete(){
            setTimeout(() => {
                let firstPuzzle = document.querySelector('.puzzle');
                let fullImg = document.querySelector('#complete-puzzle');
                let title = document.querySelector('#title');
                let reset = document.querySelector('#reset');
                let windowW = document.body.clientWidth;
                let windowH = document.body.clientHeight;
                this.isComplete = true;
                fullImg.style.top = `${parseInt(firstPuzzle.style.top) + 18.5}px` ;
                fullImg.style.left = `${parseInt(firstPuzzle.style.left) + 18.5}px`;
                fullImg.style.transform = `translate(${(windowW - 580)/2 - parseInt(fullImg.style.left)}px, ${(windowH - 580)/2 - parseInt(fullImg.style.top) + 18.5}px)`;
                title.style.opacity = 0;
                reset.style.opacity = 0;
                setTimeout(() => {
                    this.isClear = true;
                    document.querySelector('.picture').classList.add('box-shadow');
                    setTimeout(() => {
                        let intro = document.querySelector('#intro');
                        let introW = intro.offsetWidth;
                        let gap = 30;
                        intro.style.opacity = 1;
                        intro.style.transform = `translateX( ${(540 + gap)/2}px )`;
                        document.querySelector('#complete-puzzle').style.transform = `translate(${(windowW - 580)/2 - parseInt(fullImg.style.left) - (introW + gap)/2}px, ${(windowH - 580)/2 - parseInt(fullImg.style.top) + 18.5}px)`;
                    }, 1300)
                },2000)
            },1000)
        },
        getSiblsPos(e){
            let puzzles = document.querySelectorAll('.puzzle');
            let combinePuzzles = JSON.parse(`[${e.currentTarget.getAttribute('data-combine')}]`);
            let xNum = this.puzzleData.xNum;
            let yNum = this.puzzleData.yNum;
            combinePuzzles.forEach( el => {
                let top = puzzles[el].offsetTop;
                let left = puzzles[el].offsetLeft;
                this.siblsIdxArr[el].forEach( element => {
                    switch(element - el){
                        case xNum:
                            if(Math.abs(puzzles[element].offsetTop - top - 144) < 8 && 
                            Math.abs(puzzles[element].offsetLeft - left) <8){
                                this.combine(element, el, puzzles, -144, 0);
                            }
                        case 1:
                            if(Math.abs(puzzles[element].offsetTop - top) < 8 && 
                            Math.abs(puzzles[element].offsetLeft - left - 144) <8){
                                this.combine(element, el, puzzles, 0, -144);
                            }
                            break
                        case -1:
                            if(Math.abs(puzzles[element].offsetTop - top) < 8 && 
                            Math.abs(puzzles[element].offsetLeft - left + 144) <8){
                                this.combine(element, el, puzzles, -0, 144);
                            }
                            break
                        case -xNum:
                            if(Math.abs(puzzles[element].offsetTop - top + 144) < 8 && 
                            Math.abs(puzzles[element].offsetLeft - left) <8){
                                this.combine(element, el, puzzles, 144, 0);
                            }
                            break
                    }
                })
            });
            let combinePuzzlesUpdate = JSON.parse(`[${e.currentTarget.getAttribute('data-combine')}]`);
            if(combinePuzzlesUpdate.length == 9){
                this.complete();
            };
        },
        reset() {
            let num = this.puzzleData.xNum * this.puzzleData.yNum;
            let windowW = document.body.clientWidth;
            let windowH = document.body.clientHeight;
            this.zIndex = 10;
            this.siblsIdxArr = [];
            this.isClear = false;
            this.isComplete = false;
            for(i=0; i<num; i++){
                let puzzle = document.querySelectorAll('.puzzle')[i]
                let puzzleW = puzzle.offsetWidth;
                let puzzleH = puzzle.offsetHeight;
                let top = 100 + (((windowH - puzzleH) - 200) * Math.random());
                let left = (windowW - puzzleW) * Math.random();
                let zIdx = Math.floor(Math.random()*10);
                puzzle.style.top = top + 'px';
                puzzle.style.left = left + 'px';
                puzzle.style.zIndex = zIdx;
                puzzle.style.opacity = 1;
            };
            this.setData();
            this.getSiblsIdxArr();
        },
        checkPuzzle() {
            if(document.querySelector('.puzzle') == null){
                setTimeout(() => {
                    this.checkPuzzle()
                }, 100)
            }else{
                this.reset();
                this.getSiblsIdxArr();
                this.setData();
            }
        },
        playAgain() {
            this.isClear = false;
            this.isComplete = false;
            document.querySelector('#complete-puzzle').style.transform = 'scale(.8)';
            document.querySelector('#intro').style.transform = '';
            this.checkPuzzle();
        },
    },
    mounted() {
        this.reset();
        this.getSiblsIdxArr();
        this.setData();
    },
    directives: {
        drag(el,binding) {
            el.onmousedown=function(e){
                e.stopPropagation();
                let puzzles = document.querySelectorAll('.puzzle');
                let combinePuzzles = [];
                combinePuzzles = JSON.parse(`[${el.getAttribute('data-combine')}]`);
                let combineLen = combinePuzzles.length;
                let filtedArr = [];
                for(i=0; i<combineLen; i++){                            //刪除combinePuzzles內重複的項目
                    for(j=i+1; j<combineLen; j++){
                        if(combinePuzzles[i] == combinePuzzles[j]){
                            j = ++i
                        };
                    };
                    filtedArr.push(combinePuzzles[i]);
                };
                let dist = [];
                let windowW = document.body.clientWidth;
                let windowH = document.body.clientHeight;
                let puzzleH = el.offsetHeight;
                let puzzleW = el.offsetWidth;
                let filtedLeng = filtedArr.length;
                for(i=0; i<filtedLeng; i++){
                    let index = filtedArr[i];
                    dist.push({
                        x: e.clientX - puzzles[index].offsetLeft,
                        y: e.clientY - puzzles[index].offsetTop
                    })
                };
                document.onmousemove = function (e){
                    e.preventDefault();
                    let inRange = true;
                    for(i=0; i<filtedLeng; i++){
                        if(e.clientX - dist[i].x<0 || windowW - e.clientX + dist[i].x - puzzleW<0 || 
                        e.clientY - dist[i].y<0 || windowH - e.clientY + dist[i].y - puzzleH<0){
                            inRange = false;
                            break
                        }
                    };
                    if(inRange){
                        for(i=0; i<filtedLeng; i++){
                            let index = filtedArr[i];
                            puzzles[index].style.left = e.clientX - dist[i].x + 'px';
                            puzzles[index].style.top = e.clientY - dist[i].y + 'px';
                        }
                    };
                }
                document.onmouseup = function(){
                    document.onmousemove = null;
                }
            }
        }
    }
})
</script>
</body>
</html>